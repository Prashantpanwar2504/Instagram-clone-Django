Day 1: Created django project
    1. Created application name authentication,
    2. Created application name core,
    3. Created application name common,
    4. Created application name user,
    5. Created a  urls.py in the authentication application,
    6. Register the authentication urls to our project urls.py
        "path('', include('authentication.urls'))".
    7. Registered application in the apps.py file of authentication application,
    8. Created two View name SigninView and SignoutView,

Day 2: Create the Model for the user in user application the project
    1. import AbstractUser from "from django.contrib.auth.models import AbstractUser",
    2. import CustomManager for user from "from user.managers import CustomUserManager",
    3. create a User class and inherit the AbstractUser class,
    4. create field for the user like "picture", "full_name", "email", "first_name", "last_name",
    5. create a setting for the username which will help to user login,
        # which field will be use for username we can use either email or username.
        # if we not provide the USERNAME_FIELD it will take "username" by default
        USERNAME_FIELD = 'email'
        REQUIRED_FIELDS = ['full_name', ]
    6. create a object of custom user
        # Accessing Custom User Manager,we define this CustomUserManager in managers.py file into user app.
        objects = CustomUserManager()
    7. create a form.py file in authentication application in our project,
    8. create field in the form "'full_name', 'email', 'username', 'password1', 'password2'",
    9. create a functionality of SigninView and SignoutView in the view.py file of authentication application of our project.


Day 3: Sign In Page.
    1. create a url in url.py,
    2. import view form view.py,
    3. create a class based view SignInView in views.py file,
    4. create a template name,
    5. created a get method,
    6. created a post method.

Day 4: Created sign_in.html.
    1. copy the code of sign_in.html,
    2. copy the images for sign_in page,
    3. creating authentication function,
    4. import authentication function from django.contrib.auth import authenticate,
    5. created two field with same name as email & password,
    6. pass then to authentication function in post function under SignIn View function,
    7. if user is not present in the DB then Authentication function will return none,
    8. if user is present then import login,  we have to log in the user,
    9. from django.contrib.auth import authenticate, login,
    10. call the login function and redirect to 'home_feed' view.
    11. create a 'home_feed' view in core app, cuz after login core application will take care of instagram functionality,
    12. create urls.py in the core application,
    13. create new url in urls.py,
    14. now create a new view in core application,
    15. create template in core application,
    16. create a Class Based View HomeView,
    17. template_name = 'core/feed.html'.


"If we want that not one can access the functionality without login this feature will help you to do that."
Day 5: Functionality only logged in user can access the feed.html file.
    1. import a login decorator in urls.py file of core app from django.contrib.auth.decorator,
    2. call this function in path url,
        'login_required(HomeView.as_view())',
    3. open settings.py file and at the end create a setting named " LOGIN_URL = 'signin_view' "
        it will render the request to signin page, if user is not logged in and try to access feed.
    4. redirect the signup page to signin,
    5. redirect the signin page to homefeed,
    6. Signin and Signout feature working perfectly.
    7. now there is a flow if we go to the Home page we will get to the Signin page, but this is
        not what we want.
    8. To get rid of this problem go to the views.py file of authentication application,
        in the SigninView class in get method,
        we will check before render the template_name,
        if the user is already authenticated then we will not,
        render the user to the template_name = "SigninView" or homepage,
        we will send the user to the homefeed.
    9. Do same for the SignoutView in the authentication application,
        cus we don't want that if the user is already loggedin so he will redirect to signout page.

Day 6: Creating Signout View for the user.
    1. creating the signout button  in the feed.html
        Note: never do the signout with the get request methos that is the worst practice
        do with the post request.
    2. Post request in the html is done with the help of form.
    3. Created a new url for Signout the user in the authentication application,
    4. create a signout view in the authentication application.
    5. define a action int he feed.html for sending request to the signout view
            "<form method="post", action="{% url 'signout_view' %}">"
    6. create a post method in the SignoutView
    7. import logout method and call the logout method on user,
    8. redirect the page to signin View.
    9. Now on Day 6 SignIn, SignOut and SignUp Features are working properly.

Day 7: User password Reset using email.
    1. Four step to follow.
        a. PasswordResetView: Ask for the Email,
        b. PasswordResetDoneView: Show him Succeed email message,
        c. PasswordResetConfirmView: Ask to set a new password,
        d. PasswordResetCompleteView: Successfully Reset your password,
    2. Create a new url to pass for the password reset page in the authentication application in out project,
    3. create new url in auth app for show him succeed email message,
    4. create new url in auth app for confirming,
    5. create new url in auth app for completing the process and redirect to signin page,
    6. Creating the Templates for all four view.
    7. creating the view for PasswordRestView to ask for thr Email as name of PRView,
    8. Import PasswordResetView form django.config.auth.views import PasswordResetView
    9. Import PasswordResetConfirmView form django.config.auth.views import PasswordResetView
    10. create a view for confirming the email with the name 'PRConfirmView'
    11. pass a keyword argument to the PRConfirmView url,

Day 8: ConnectionRefusedError at /password/reset/- error and out the handle it.
    we don't define the configuration for the email, we can send email with the help of Django framework.
    first we have to define the configuration for the email.
    1. Open the settings.py file and define the setting for the email,
    2. first setting 'EMAIL_PORT' for email and gmail we use port '587'
    3. second setting 'EMAIL_USE_TLs' = True, this use for encryption of the message stands for the transport
    Layer Security, which work same like SSL with with some extra functionality
    4. third setting 'EMAIL_HOST' = 'smtp.gmail.com', hosting services we want to use for the email.
    5. fourth setting 'EMAIL_HOST_USER' = 'admin ka mail_id', kiske email se email send karna chahate ho,
    6. 5th setting 'EMAIL_HOST_PASSWORD' = '', Kuch be rakhna but apna gmail ka real password mat rakhna
    we have to remember two things,
    7. Error: Authentication Required
        [
        SMTPSenderRefused at /password/reset/
            (530, b'5.7.0 Authentication Required.
            Learn more at\n5.7.0  https://support.google.com/mail/?p=WantAuthError t1sm8537145pjo.33 - gsmtp',
            'webmaster@localhost')
        ]
        pass render password to check further.
    8. Username & Password does't Match.
        [
        SMTPAuthenticationError at /password/reset/
        (535, b'5.7.8 Username and Password not accepted.
        Learn more at\n5.7.8  https://support.google.com/mail/?p=BadCredentials 145sm8735313pfv.196 - gsmtp'
        ]

        gmail can give us this type of error through smtp library.
    9.  if we want to test email sending link feature,
    10. create a new setting for email_backend,
    11. create a new setting for email_file called EMAIL_FILE_PATH,
    12. now create a new url for the password_reset_done_view,
    13. create a new view name with PRDoneView,
    14. import PasswordResetDoneView from django.contrib.auth.views,
    15. restart the server.
    16. Everything will be work fine but, after getting the link in the file when we go to the that link
        and when we type the new password we will get the new error
    17. Reverse for 'password_reset_complete' not found.
        [
        NoReverseMatch at /password/reset/confirm/MTM/set-password
        Reverse for 'password_reset_complete' not found. 'password_reset_complete' i
        s not a valid view function or pattern name.
        ]
    18. create a new url for password_reset_complete
    19. create a new view for password_reset_complete_view.
    20. Every thing is working properly but we are getting email in file.
        every email link will work only one time second time it will become invalid or expire.
    21. if we don't want to create all the views for password reset in the views.py file.
    22. we can call directly view in thr urls.py file by importing all thr password reset view.
    23. Import all the view for password reset view
        from django.contrib.auth.views import (PasswordResetView,
                                       PasswordResetDoneView,
                                       PasswordResetConfirmView,
                                       PasswordResetCompleteView
                                       )
    24. update the urls.
        we can use keyword argument to call templates.
    25. in the use call PasswordResetView.as_view(),
    26. pass template_name in the as_view(), as a Keyworded argument
        path('password/reset/', PasswordResetView.as_view(
        template_name='authentication/password_reset.html',
        email_template_name='authentication/password_reset_email.html'
        )
    27. remove all the class based views from the views.py file.
    28. restart your server and all thing will word properly.
        we don't need to create the class ofr the password reset views we can do this instead.

Day 9: Login via Username.
    1. go to signin template and check for the type fof the input field
    2. Goto email field and change the type of field from email to text cuz we want to login by email and username both.
    3. go to the views.py file and update the email field with "email_username = request.POST.get('email_username')"
    but in the models.py of user we create USERNAME_FIELD = 'email'
    4. at the end we have to login by email so we need the email of the user although we provide the username.
    5. in the views.py file we can do one thing, we can find the object of user with the help of email_username field and them we can get
    6. import user model in the views.py file from get_user_model
    7. the email of that user with the help if '.'
        user_object = User.objects.get(username = email_username)
    8. getting the email from the user object
        email = user_object.email
    9. restart the server and authentication will word for username.

Day 10: Login by Email.
    1. when thw login is working for the username, so if we trying to login by email it will raise an error
    "DoesNotExist at /
        User matching query does not exist."
        cuz we write code for the username login feature.
    2. To get rid of this error we can use try and catch block.
    3. put the username login code in the try block cuz this is the code which is raising the error
        "try:
            user_object = User.objects.get(username=email_username)
            email = user_object.email
        except Exception as e:
            print(e)
            email = email_username  #
    4. restart the server now user cna login by both username as well as email

